<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>AR Robot Hospital</title>
<style>
  html,body{height:100%;margin:0;background:#000;}
  #ui {
    position:fixed; left:12px; bottom:12px; z-index:10;
    background:rgba(0,0,0,0.55); color:#fff; padding:10px 12px;
    border-radius:10px; font-family:system-ui,Segoe UI,Roboto,sans-serif;
    font-size:14px;
  }
</style>
</head>
<body>
<div id="ui">Move phone slowly to find a surface â†’ Tap to place the robot</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128/build/three.module.js';
import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.128/examples/jsm/webxr/ARButton.js';

let scene, camera, renderer;
let reticle, hitTestSource = null, localRefSpace = null;
let robot = null, bedsPlaced = false;

init();
start();

function init(){
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 40);

  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  // lighting
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(1,2,1);
  scene.add(dir);

  // reticle
  const ringGeo = new THREE.RingGeometry(0.12, 0.15, 32);
  ringGeo.rotateX(-Math.PI/2);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
  reticle = new THREE.Mesh(ringGeo, ringMat);
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  // AR Button (request hit-test)
  document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

  renderer.xr.addEventListener('sessionstart', onSessionStart);
  renderer.xr.addEventListener('sessionend', onSessionEnd);

  window.addEventListener('resize', onResize);
  window.addEventListener('click', placeAtReticle);
}

function onResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

async function onSessionStart(){
  const session = renderer.xr.getSession();
  const viewerSpace = await session.requestReferenceSpace('viewer');
  hitTestSource = await session.requestHitTestSource({ space: viewerSpace });
  localRefSpace = renderer.xr.getReferenceSpace();
}

function onSessionEnd(){
  hitTestSource = null;
  localRefSpace = null;
  reticle.visible = false;
}

function start(){
  renderer.setAnimationLoop(render);
}

function render(time, frame){
  if (frame && hitTestSource && localRefSpace){
    const hits = frame.getHitTestResults(hitTestSource);
    if (hits.length){
      const hit = hits[0];
      const pose = hit.getPose(localRefSpace);
      reticle.visible = true;
      reticle.matrix.fromArray(pose.transform.matrix);
    } else {
      reticle.visible = false;
    }
  }
  renderer.render(scene, camera);
}

// --- simple robot model (group)
function createRobot(){
  const group = new THREE.Group();

  const bodyMat = new THREE.MeshStandardMaterial({ color: 0xf8f8f8, roughness: 0.2, metalness: 0.1 });
  const body = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.5, 0.25), bodyMat);
  body.position.y = 0.25;
  group.add(body);

  const screenMat = new THREE.MeshStandardMaterial({ color: 0x0b0b0b, emissive: 0x113344, emissiveIntensity: 0.35, metalness: 0.8, roughness: 0.3 });
  const screen = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.14, 0.03), screenMat);
  screen.position.set(0, 0.37, 0.14);
  group.add(screen);

  const eyeMat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00cccc, emissiveIntensity: 0.8 });
  const leftEye = new THREE.Mesh(new THREE.BoxGeometry(0.06,0.06,0.02), eyeMat);
  const rightEye = leftEye.clone();
  leftEye.position.set(-0.06, 0.36, 0.16);
  rightEye.position.set(0.06, 0.36, 0.16);
  group.add(leftEye, rightEye);

  const wheelMat = new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.9 });
  const wheelGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.04, 24);
  const offsets = [[-0.16,0.08,0.10],[0.16,0.08,0.10],[-0.16,0.08,-0.10],[0.16,0.08,-0.10]];
  offsets.forEach(o => {
    const w = new THREE.Mesh(wheelGeo, wheelMat);
    w.rotation.z = Math.PI/2;
    w.position.set(o[0], o[1], o[2]);
    group.add(w);
  });

  return group;
}

// create two simple beds
function createBedAt(x,y,z){
  const base = new THREE.Mesh(new THREE.BoxGeometry(0.9,0.12,0.45), new THREE.MeshStandardMaterial({color:0x999999}));
  base.position.set(x, y + 0.06, z);
  scene.add(base);

  const mattress = new THREE.Mesh(new THREE.BoxGeometry(0.9,0.08,0.45), new THREE.MeshStandardMaterial({color:0xffefef}));
  mattress.position.set(x, y + 0.16, z);
  scene.add(mattress);
}

function placeAtReticle(){
  if (!reticle.visible) return;

  if (!robot){
    robot = createRobot();
    scene.add(robot);
  }

  // position robot at the reticle
  const m = new THREE.Matrix4().copy(reticle.matrix);
  const pos = new THREE.Vector3().setFromMatrixPosition(m);
  robot.position.copy(pos);

  // place beds once
  if (!bedsPlaced){
    const y = pos.y;
    createBedAt(pos.x + 0.8, y, pos.z - 0.9);
    createBedAt(pos.x - 0.8, y, pos.z - 0.9);
    bedsPlaced = true;
  }
}
</script>
</body>
</html>
