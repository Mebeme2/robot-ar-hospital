<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Robot Mission</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: transparent;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #arContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 14px;
        }

        #instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            z-index: 1000;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-size: 14px;
        }

        #missionMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            background: linear-gradient(135deg, #00bcd4, #4caf50);
            color: white;
            padding: 30px 50px;
            border-radius: 20px;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 188, 212, 0.5);
            opacity: 0;
            pointer-events: none;
            transition: all 0.5s ease;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        #missionMessage.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.1);
        }

        .control-btn {
            background: linear-gradient(45deg, #00bcd4, #0097a7);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s ease;
            font-size: 12px;
            font-weight: 500;
        }

        .control-btn:hover {
            background: linear-gradient(45deg, #00acc1, #00838f);
            transform: translateY(-1px);
        }

        #startAR {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1500;
            background: linear-gradient(45deg, #00bcd4, #4caf50);
            color: white;
            border: none;
            padding: 20px 40px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 8px 25px rgba(0, 188, 212, 0.4);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ar.js/2.2.2/ar.min.js"></script>
</head>
<body>
    <div id="arContainer">
        <button id="startAR">Start AR Experience</button>
        
        <div id="ui" style="display: none;">
            <div><strong>AR Robot Mission</strong></div>
            <div>Status: <span id="status">Ready</span></div>
            <div>Mission: Tap the bed to send robot</div>
            <button class="control-btn" id="resetRobot">Reset Robot</button>
        </div>

        <div id="instructions" style="display: none;">
            <strong>Instructions:</strong><br>
            â€¢ Point camera at a flat surface<br>
            â€¢ Tap the bed to send the robot on a mission<br>
            â€¢ Watch the robot navigate to the target
        </div>

        <div id="missionMessage">
            ðŸŽ‰ MISSION SUCCESS! ðŸŽ‰<br>
            <div style="font-size: 16px; margin-top: 10px;">Robot reached the bed!</div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, arContext;
        let robot, bed, robotGroup, bedGroup;
        let isARActive = false;
        let isMoving = false;
        let eyeMaterials = [];
        let eyeLights = [];
        let robotOriginalPosition = new THREE.Vector3(0, 0, 0);
        let bedPosition = new THREE.Vector3(5, 0, 5);
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        function initAR() {
            // Initialize AR context
            arContext = new ARjs.Context({
                cameraParametersUrl: 'https://cdn.jsdelivr.net/npm/@ar-js-org/ar.js@3.3.3/data/data/camera_para.dat',
                detectionMode: 'mono'
            });

            arContext.init(() => {
                camera.projectionMatrix.copy(arContext.getProjectionMatrix());
            });

            // Initialize Three.js scene
            scene = new THREE.Scene();
            
            camera = new THREE.Camera();
            camera.matrixAutoUpdate = false;
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                precision: 'highp'
            });
            renderer.setClearColor(new THREE.Color('lightgrey'), 0);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = '0px';
            renderer.domElement.style.left = '0px';
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            document.getElementById('arContainer').appendChild(renderer.domElement);

            // AR source (markerless)
            const arSource = new ARjs.Source({ sourceType: 'webcam' });
            arSource.init(() => {
                onResize();
            });

            // Create marker
            const arMarker = new ARjs.Anchor({
                anchor: arSource
            });
            scene.add(arMarker);

            setupLighting();
            createRobot();
            createBed();
            createEnvironment();
            setupControls();
            
            // Add objects to marker
            arMarker.add(robotGroup);
            arMarker.add(bedGroup);

            animate();
        }

        function setupLighting() {
            const keyLight = new THREE.DirectionalLight(0xffffff, 1.5);
            keyLight.position.set(3, 4, 2);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 2048;
            keyLight.shadow.mapSize.height = 2048;
            keyLight.shadow.camera.near = 0.1;
            keyLight.shadow.camera.far = 20;
            keyLight.shadow.camera.left = -5;
            keyLight.shadow.camera.right = 5;
            keyLight.shadow.camera.top = 5;
            keyLight.shadow.camera.bottom = -5;
            scene.add(keyLight);

            const fillLight = new THREE.DirectionalLight(0x4a90e2, 0.3);
            fillLight.position.set(-2, 3, -2);
            scene.add(fillLight);

            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
        }

        function createRobot() {
            robotGroup = new THREE.Group();
            robot = new THREE.Group();

            const bodyMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0xf8f8f8, 
                roughness: 0.15, 
                metalness: 0.05, 
                clearcoat: 0.3 
            });
            const plasticMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x2c2c2c, 
                roughness: 0.3, 
                metalness: 0.1 
            });
            const rubberMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0xFFFF00, 
                roughness: 0.9, 
                metalness: 0.0 
            });

            // Scale down for AR
            const scale = 0.3;

            // Body
            const bodyGeometry = new THREE.BoxGeometry(2.5 * scale, 3.5 * scale, 2 * scale);
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 2 * scale, 0);
            body.castShadow = true;
            body.receiveShadow = true;
            robot.add(body);

            // Screen
            const screenGeometry = new THREE.BoxGeometry(1.6 * scale, 1.0 * scale, 0.15 * scale);
            const screenMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x0a0a0a, 
                roughness: 0.1, 
                metalness: 0.9,
                emissive: 0x001122, 
                emissiveIntensity: 0.3
            });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.set(0, 3.0 * scale, 1.0 * scale);
            robot.add(screen);

            // Eyes
            const eyeGeometry = new THREE.BoxGeometry(0.28 * scale, 0.28 * scale, 0.05 * scale);
            const eyeMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x00ffff, 
                emissive: 0x00aaaa, 
                emissiveIntensity: 1.5,
                transparent: true, 
                opacity: 0.95, 
                roughness: 0.1, 
                metalness: 0.1
            });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
            leftEye.position.set(-0.35 * scale, 3.0 * scale, 1.08 * scale);
            robot.add(leftEye);
            eyeMaterials.push(leftEye.material);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
            rightEye.position.set(0.35 * scale, 3.0 * scale, 1.08 * scale);
            robot.add(rightEye);
            eyeMaterials.push(rightEye.material);

            // Eye Lights
            const leftEyeLight = new THREE.PointLight(0x00ffff, 1.0, 2);
            leftEyeLight.position.set(-0.35 * scale, 3.0 * scale, 1.15 * scale);
            robot.add(leftEyeLight);
            eyeLights.push(leftEyeLight);
            
            const rightEyeLight = new THREE.PointLight(0x00ffff, 1.0, 2);
            rightEyeLight.position.set(0.35 * scale, 3.0 * scale, 1.15 * scale);
            robot.add(rightEyeLight);
            eyeLights.push(rightEyeLight);

            // Chassis
            const chassisGeometry = new THREE.BoxGeometry(2.8 * scale, 0.4 * scale, 1.8 * scale);
            const chassis = new THREE.Mesh(chassisGeometry, plasticMaterial);
            chassis.position.set(0, 0.3 * scale, 0);
            chassis.castShadow = true;
            robot.add(chassis);

            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.45 * scale, 0.45 * scale, 0.25 * scale, 16);
            const wheelPositions = [
                [-1.2 * scale, 0.45 * scale, 0.7 * scale], 
                [1.2 * scale, 0.45 * scale, 0.7 * scale],
                [-1.2 * scale, 0.45 * scale, -0.7 * scale], 
                [1.2 * scale, 0.45 * scale, -0.7 * scale]
            ];
            
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, rubberMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos[0], pos[1], pos[2]);
                wheel.castShadow = true;
                robot.add(wheel);
            });

            robotGroup.add(robot);
            robotGroup.position.copy(robotOriginalPosition);
        }

        function createBed() {
            bedGroup = new THREE.Group();
            
            const bedMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x8B4513, 
                roughness: 0.8, 
                metalness: 0.1 
            });
            const mattressMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0xFFFFFF, 
                roughness: 0.9, 
                metalness: 0.0 
            });
            const pillowMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0xFFF8DC, 
                roughness: 0.8, 
                metalness: 0.0 
            });

            const scale = 0.4;

            // Bed frame
            const frameGeometry = new THREE.BoxGeometry(4 * scale, 0.3 * scale, 2 * scale);
            const bedFrame = new THREE.Mesh(frameGeometry, bedMaterial);
            bedFrame.position.set(0, 0.15 * scale, 0);
            bedFrame.castShadow = true;
            bedFrame.receiveShadow = true;
            bedGroup.add(bedFrame);

            // Mattress
            const mattressGeometry = new THREE.BoxGeometry(3.8 * scale, 0.4 * scale, 1.8 * scale);
            const mattress = new THREE.Mesh(mattressGeometry, mattressMaterial);
            mattress.position.set(0, 0.5 * scale, 0);
            mattress.castShadow = true;
            mattress.receiveShadow = true;
            bedGroup.add(mattress);

            // Pillow
            const pillowGeometry = new THREE.BoxGeometry(1 * scale, 0.2 * scale, 0.6 * scale);
            const pillow = new THREE.Mesh(pillowGeometry, pillowMaterial);
            pillow.position.set(-1.2 * scale, 0.8 * scale, 0);
            pillow.castShadow = true;
            pillow.receiveShadow = true;
            bedGroup.add(pillow);

            // Bed legs
            const legGeometry = new THREE.BoxGeometry(0.1 * scale, 0.6 * scale, 0.1 * scale);
            const legPositions = [
                [-1.8 * scale, -0.15 * scale, 0.8 * scale],
                [1.8 * scale, -0.15 * scale, 0.8 * scale],
                [-1.8 * scale, -0.15 * scale, -0.8 * scale],
                [1.8 * scale, -0.15 * scale, -0.8 * scale]
            ];

            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, bedMaterial);
                leg.position.set(pos[0], pos[1], pos[2]);
                leg.castShadow = true;
                bedGroup.add(leg);
            });

            bedGroup.position.copy(bedPosition);
            bedGroup.name = 'bed'; // For raycasting
        }

        function createEnvironment() {
            // Ground plane
            const groundGeometry = new THREE.PlaneGeometry(20, 20);
            const groundMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x2a2a2a, 
                roughness: 0.8, 
                metalness: 0.1,
                transparent: true,
                opacity: 0.3
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function setupControls() {
            renderer.domElement.addEventListener('click', onMouseClick, false);
            
            document.getElementById('resetRobot').addEventListener('click', () => {
                resetRobot();
            });
        }

        function onMouseClick(event) {
            if (isMoving) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(bedGroup.children, true);

            if (intersects.length > 0) {
                moveRobotToBed();
            }
        }

        function moveRobotToBed() {
            if (isMoving) return;
            
            isMoving = true;
            document.getElementById('status').textContent = 'Moving to bed...';
            
            const startPosition = robotGroup.position.clone();
            const endPosition = new THREE.Vector3(bedPosition.x - 1, 0, bedPosition.z);
            const duration = 3000; // 3 seconds
            const startTime = Date.now();

            function animateMovement() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Smooth easing
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                robotGroup.position.lerpVectors(startPosition, endPosition, easeProgress);
                
                // Add floating animation
                robotGroup.position.y = Math.sin(elapsed * 0.005) * 0.1;
                
                // Rotate robot towards bed
                robotGroup.lookAt(bedPosition.x, robotGroup.position.y, bedPosition.z);
                
                if (progress < 1) {
                    requestAnimationFrame(animateMovement);
                } else {
                    // Mission complete
                    showMissionSuccess();
                    document.getElementById('status').textContent = 'Mission Complete!';
                    setTimeout(() => {
                        isMoving = false;
                        document.getElementById('status').textContent = 'Ready';
                    }, 2000);
                }
            }
            
            animateMovement();
        }

        function showMissionSuccess() {
            const message = document.getElementById('missionMessage');
            message.classList.add('show');
            
            setTimeout(() => {
                message.classList.remove('show');
            }, 3000);
        }

        function resetRobot() {
            if (isMoving) return;
            
            robotGroup.position.copy(robotOriginalPosition);
            robotGroup.rotation.set(0, 0, 0);
            document.getElementById('status').textContent = 'Robot Reset';
            
            setTimeout(() => {
                document.getElementById('status').textContent = 'Ready';
            }, 1000);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (arContext && isARActive) {
                arContext.update(arContext.arController.canvas);
            }
            
            // Animate robot eyes
            if (robot) {
                const time = Date.now() * 0.001;
                robot.rotation.y += 0.002;
                
                eyeMaterials.forEach((mat, i) => {
                    mat.emissiveIntensity = 1.0 + 0.3 * Math.sin(time + i * 0.3);
                });
                
                eyeLights.forEach((light, i) => {
                    light.intensity = 0.8 + 0.2 * Math.sin(time + i * 0.3);
                });
            }
            
            renderer.render(scene, camera);
        }

        function onResize() {
            arContext.arController.onResizeElement();
            arContext.arController.copyElementSizeTo(renderer.domElement);
            if (arContext.arController.orientationChangeResize) {
                arContext.arController.orientationChangeResize();
            }
        }

        // Start AR experience
        document.getElementById('startAR').addEventListener('click', () => {
            document.getElementById('startAR').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('instructions').style.display = 'block';
            isARActive = true;
            initAR();
        });

        window.addEventListener('resize', onResize);
    </script>
</body>
</html>
