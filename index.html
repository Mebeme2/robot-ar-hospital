<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>AR Robot Hospital Mission</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#cfe0f2;}
  #ui {
    position:fixed; left:12px; bottom:12px; z-index:10;
    background:rgba(0,0,0,0.55); color:#fff; padding:10px 12px;
    border-radius:10px; font-family:system-ui,Segoe UI,Roboto,sans-serif;
    font-size:14px;
  }
  canvas{display:block;}
</style>
</head>
<body>
<div id="ui">Tap the robot to start the mission, then tap a bed to deliver medicine.</div>

<!-- Confetti library -->
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128/build/three.module.js';
import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.128/examples/jsm/webxr/ARButton.js';

let scene, camera, renderer;
let reticle, hitTestSource = null, localRefSpace = null;
let robot = null, beds = [], targets = [];
let missionStep = 0, bedsPlaced = false;
let floatingMessages = [];

// --- Initialize scene ---
init();
animate();

function init(){
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 40);

  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  // lighting
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(1,2,1);
  scene.add(dir);

  // Reticle for placement
  const ringGeo = new THREE.RingGeometry(0.12, 0.15, 32);
  ringGeo.rotateX(-Math.PI/2);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
  reticle = new THREE.Mesh(ringGeo, ringMat);
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  // ARButton
  document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

  renderer.xr.addEventListener('sessionstart', onSessionStart);
  renderer.xr.addEventListener('sessionend', onSessionEnd);

  window.addEventListener('resize', onResize);
  window.addEventListener('click', onScreenTap);
}

// --- Resize ---
function onResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// --- AR session ---
async function onSessionStart(){
  const session = renderer.xr.getSession();
  const viewerSpace = await session.requestReferenceSpace('viewer');
  hitTestSource = await session.requestHitTestSource({ space: viewerSpace });
  localRefSpace = renderer.xr.getReferenceSpace();
}

function onSessionEnd(){
  hitTestSource = null;
  localRefSpace = null;
  reticle.visible = false;
}

// --- Tap handler ---
function onScreenTap(){
  if(!reticle.visible) return;

  const m = new THREE.Matrix4().copy(reticle.matrix);
  const pos = new THREE.Vector3().setFromMatrixPosition(m);

  if(!robot){
    robot = createRobot();
    robot.position.copy(pos);
    scene.add(robot);
    // place beds around robot
    placeBeds(pos);
  } else {
    // assign next target bed
    if(missionStep < beds.length){
      targets[missionStep] = pos.clone();
      missionStep++;
    }
  }
}

// --- Create simple robot ---
function createRobot(){
  const group = new THREE.Group();
  const bodyMat = new THREE.MeshStandardMaterial({ color:0xf8f8f8, roughness:0.2, metalness:0.1 });
  const body = new THREE.Mesh(new THREE.BoxGeometry(0.35,0.5,0.25), bodyMat);
  body.position.y = 0.25;
  group.add(body);

  const screen = new THREE.Mesh(new THREE.BoxGeometry(0.22,0.14,0.03), new THREE.MeshStandardMaterial({ color:0x0b0b0b, emissive:0x113344, emissiveIntensity:0.35 }));
  screen.position.set(0,0.37,0.14);
  group.add(screen);

  const eyeMat = new THREE.MeshStandardMaterial({ color:0x00ffff, emissive:0x00cccc, emissiveIntensity:0.8 });
  const leftEye = new THREE.Mesh(new THREE.BoxGeometry(0.06,0.06,0.02), eyeMat);
  const rightEye = leftEye.clone();
  leftEye.position.set(-0.06,0.36,0.16); rightEye.position.set(0.06,0.36,0.16);
  group.add(leftEye,rightEye);

  return group;
}

// --- Place two beds ---
function placeBeds(robotPos){
  if(bedsPlaced) return;
  const bedOffset = 0.8;
  const positions = [
    new THREE.Vector3(robotPos.x + bedOffset, robotPos.y, robotPos.z - 0.9),
    new THREE.Vector3(robotPos.x - bedOffset, robotPos.y, robotPos.z - 0.9)
  ];
  positions.forEach(pos => {
    const base = new THREE.Mesh(new THREE.BoxGeometry(0.9,0.12,0.45), new THREE.MeshStandardMaterial({color:0x999999}));
    base.position.set(pos.x,pos.y+0.06,pos.z);
    const mattress = new THREE.Mesh(new THREE.BoxGeometry(0.9,0.08,0.45), new THREE.MeshStandardMaterial({color:0xffefef}));
    mattress.position.set(pos.x,pos.y+0.16,pos.z);
    scene.add(base,mattress);
    beds.push(pos);
  });
  bedsPlaced = true;
}

// --- Floating message ---
function showMessage(text, position){
  const canvas = document.createElement('canvas');
  canvas.width = 256; canvas.height = 128;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = "rgba(255,255,255,0)";
  ctx.fillRect(0,0,256,128);
  ctx.font = "20px Arial"; ctx.fillStyle = "#ff3399";
  ctx.textAlign = "center"; ctx.fillText(text,128,64);
  const texture = new THREE.CanvasTexture(canvas);
  const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent:true });
  const sprite = new THREE.Sprite(spriteMat);
  sprite.position.copy(position);
  sprite.position.y += 0.5;
  sprite.scale.set(0.6,0.3,0.3);
  scene.add(sprite);
  floatingMessages.push(sprite);
  setTimeout(()=>{ scene.remove(sprite); },2000);
}

// --- Animate / move robot ---
function animate(){
  renderer.setAnimationLoop(render);
}

function render(time, frame){
  // Update reticle
  if(frame && hitTestSource && localRefSpace){
    const hits = frame.getHitTestResults(hitTestSource);
    if(hits.length){
      const hit = hits[0];
      const pose = hit.getPose(localRefSpace);
      reticle.visible = true;
      reticle.matrix.fromArray(pose.transform.matrix);
    } else reticle.visible = false;
  }

  // Robot movement
  if(robot && missionStep > 0){
    const target = beds[0];
    for(let i=0;i<beds.length;i++){
      const t = targets[i];
      if(t){
        const dir = new THREE.Vector3().subVectors(t, robot.position);
        if(dir.length() > 0.02){
          dir.multiplyScalar(0.05);
          robot.position.add(dir);
        } else {
          showMessage("Medicine delivered!", t);
          targets[i] = null;
        }
      }
    }

    // Confetti when all beds done
    if(targets.every(t=>t===null)){
      if(!window.missionComplete){
        window.missionComplete = true;
        showMessage("Mission Successful!", robot.position);
        confetti({ particleCount: 200, spread: 120, origin:{y:0.6} });
      }
    }
  }

  renderer.render(scene,camera);
}
</script>
</body>
</html>
